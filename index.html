<!doctype html>
<!--suppress CheckImageSize -->
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Présentation Angular</title>

    <meta name="description" content="Exploring the GitHub Service Universe">
    <meta name="author" content="Bjoern Kimminich">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <link rel="stylesheet" href="css/custom.css">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
        if (window.location.search.match(/print-pdf/gi)) {
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = 'css/print/pdf.css';
            document.getElementsByTagName('head')[0].appendChild(link);
        }
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section>
            <img src="assets/angular/angular.png" class="heart" width="200"
                 style="background: none; border:none; box-shadow:none;"/>

            <h1>Angular</h1>
            <p>
                <small>Présenté par: <a href="http://houdass.com">Youness Houdass</a></small>
            </p>
            <p>
                <small>Email: <a href="#">Houd.youness@gmail.com</a></small>
            </p>
            <p>
                <a href="https://houdass.github.io/angular-netgroup-slides">https://houdass.github.io/angular-netgroup-slides</a>
            </p>
            <p>
                <a href="http://angular.io/">http://angular.io/</a>
            </p>
        </section>

        <!-- I- Introduction -->
        <section>
            <section>
                <h2>I- Introduction</h2>
            </section>
        </section>

        <!-- I- 1. Présentation d'angular -->
        <section>
            <section>
                <h2>I- 1. Qu'est ce que angular?</h2>
                <img src="assets/angular/jimcarrey.gif" width="500"/>
            </section>
            <section>
                <p>Angular est une plateforme de développement qui permet de créer des applications clientes web, il est
                    aussi utilisé pour la création d’application mobile, notamment avec Ionic.</p>
            </section>
            <section>
                <p>Angular permet de créer des applications SPA (single page application).</p>
            </section>
        </section>

        <!-- I- 2. AngularJS vs. Angular2+ -->
        <section>
            <section>
                <h2>I- 2. AngularJS vs. Angular2+</h2>
                <img src="assets/angular/angularvsangularjs.gif" width="500"/>
            </section>
            <section>
                <p>Le terme AngularJS désigne la version 1.x.x du framework, et les versions supérieures ou égale à 2
                    sont nommées simplement Angular.</p>
            </section>
            <section>
                <p>Si vous connaissez AngularJS (Angular 1.x), vous pensez peut-être qu’Angular est une upgrade
                    d’AngularJS. En réalité, Angular a été totalement réécrit par Google, ce qui en fait un nouveau
                    framework à part entière, avec une philosophie et des concepts propres à lui.</p>
                <img src="assets/angular/1.gif" width="500"/>
            </section>
            <section>
                <h4>
                    Au travers d’Angular, Google cherche à faire table rase du passé, en remettant à plat de nombreux
                    concepts présents dans AngularJS.
                </h4>
                <p>
                    Cette stratégie a été motivée par 4 principes fondateurs
                <ul>
                    <li>Augmenter les performances</li>
                    <li>Améliorer la productivité</li>
                    <li>S’adapter au mobile</li>
                    <li>Embrasser les nouveaux standards du Web</li>
                </ul>
                </p>
            </section>
            <section>
                <h3>Avantages</h3>
                <ul>
                    <li>Des performances améliorées</li>
                    <li>Une modularité accrue / du code plus expressif</li>
                    <li>Un respect des nouveaux standards du web</li>
                </ul>
            </section>
        </section>

        <!-- I- 3. Historique des versions Angular N -->
        <section>
            <section>
                <h2>I- 3. Historique des versions Angular N</h2>
            </section>
            <section>
                <h3>Un peu d'histoire</h3>
                <ul>
                    <li>Angular 2: September 2016</li>
                    <li>Angular 4: Mars 2017 (Pas de version 3, car toutes les bibliothèques Angular de base étaient
                        toutes à la version v2.3.0, sauf le paquet @angular/router qui était à la v3.3.0)
                    </li>
                    <li>Angular 5: November 2017</li>
                    <li>Angular 6: Mai 2018</li>
                    <li>Angular 7: Octobre 2018</li>
                    <li>Angular 8: Prochainement (Mars/Avril)</li>
                </ul>
                <img src="assets/angular/2.png" width="400"/>
            </section>
            <section>
                <h3>Nouveautés Angular 4</h3>
                <ul>
                    <li>Disponible depuis Mars 2017</li>
                    <li>*ngIf et ng-template</li>
                    <li>*ngIf et asynchronisme</li>
                    <li>Renderer2</li>
                    <li>Directive email</li>
                    <li>Les animations</li>
                    <li>Titlecase</li>
                    <li>Http deprecated => HttpClient</li>
                </ul>
            </section>
            <section>
                <h3>Nouveautés Angular 5</h3>
                <ul>
                    <li>Disponible depuis Novembre 2017</li>
                    <li>Angular 4 recompile tous les fichiers à chaque changement, ce qui le rend trop lent en phase de
                        développement
                    </li>
                    <li>Angular 5 introduit une option watch, il compile que les fichiers nécessaire, ce qui le rend
                        ultra rapide
                    </li>
                    <li>Le temps de compilation est passé de 12-14 secondes à 2-3 secondes sur un projet de moyenne
                        taille
                    </li>
                    <li>Les pipes i18n: number, percent, currency, date</li>
                </ul>
            </section>
            <section>
                <h3>Nouveautés Angular 6</h3>
                <ul>
                    <li>Component Dev Kit (CDK): ensemble complet de composants accessibles, performants et riches en
                        fonctionnalités
                    </li>
                    <li>Angular Elements</li>
                    <li>Nouveau moteur de rendu "Ivy":
                        <small>moteur de rendu qui réduira la taille des applications, accélèrera le temps de
                            compilation et sera plus facile à débugger. C’est en tous cas la promesse de l’équipe
                            Angular, qui assure par ailleurs que la transition vers ce nouveau moteur de rendu se fera
                            tout en douceur
                        </small>
                    </li>
                    <li>Schematics et ng update</li>
                    <li>Bazel:
                        <small>un outil de build</small>
                    </li>
                    <li>Service Workers et Progressive Web Apps</li>
                    <li>Tree-shakable providers:
                        <small>Au lieu de déclarer un service dans un module particulier pour ensuite l’importer, il est
                            désormais possible de le faire dans le service lui-même
                        </small>
                    </li>
                </ul>
            </section>
            <section>
                <h3>Nouveautés Angular 7</h3>
                <ul>
                    <li>Disponible depuis Octobre 2018</li>
                    <li>Virtual Scroll</li>
                    <li>Drag & Drop</li>
                    <li>Support du Typescript 3.1</li>
                    <li>Progrès d’Ivy</li>
                </ul>
            </section>
        </section>

        <!-- I- 4. Setup projet -->
        <section>
            <section>
                <h2>I- 4. Setup projet</h2>
            </section>
            <section>
                <h6>
                    git clone https://github.com/houdass/angular-netgroup-demo.git
                </h6>
            </section>
            <section>
                <h6>
                    npm i -S bootstrap@3.3.7
                </h6>
                <h6>
                    @import '~bootstrap/dist/css/bootstrap.min.css';
                </h6>
            </section>
        </section>

        <!-- I- 5. Angular CLI -->
        <section>
            <section>
                <h2>I- 5. Angular CLI</h2>
                <img src="assets/angular/angular.svg" width="400"
                     style="background: none; border:none; box-shadow:none;"/>
            </section>
            <section>
                <p>
                    "The CLI is a geart tool for big and very big Angular projects! It allows to focus on Angular code
                    instead of workflow tasks."
                </p>
                <p>
                    Google nous propose un outil clé en main pour réaliser les tâches de développement les plus
                    courantes. Ce projet est basé sur le projet Open Source ember CLI, qui a maintenant plus de trois
                    ans. Grâce à notre Angular Cli, il est possible de:
                <ul>
                    <li>Créer une application from scratch via un scaffolding</li>
                    <li>Générer des component|directive|pipe|service|class|guard|interface|enum|module</li>
                    <li>Builder un projet</li>
                    <li>Lancer des tests de End-to-End (E2E) ou unitaires</li>
                    <li>Et beaucoup d'autres choses…</li>
                </ul>
                </p>
            </section>
            <section>
                <p>
                <ul>
                    <li>npm i -g @angular/cli</li>
                    <li>ng new angular-netgroup-demo</li>
                    <li>ng new angular-netgroup-demo --style=less|scss|less|stylus</li>
                    <li>cd angular-netgroup-demo</li>
                    <li>ng serve</li>
                </ul>
                </p>
            </section>
        </section>

        <!-- I- 6. TypeScript, C'est quoi ? -->
        <section>
            <section>
                <h2>I- 6. TypeScript, C'est quoi ?</h2>
                <img src="assets/angular/typescript.jpg" width="500"/>
            </section>
            <section>
                <p>
                    TypeScript est un langage open source développé par Microsoft. C’est un sur-ensemble typé
                    de JavaScript qui compile vers du JavaScript standard
                </p>
            </section>
            <section>
                <p>
                    TypeScript existe depuis 2012. Le plus important étant le système de type, lui donnant même son nom.
                </p>
                <p>
                    Depuis la version 1.5, sortie en 2015, cette bibliothèque essaie d’être un sur-ensemble d’ES6, et
                    quelques nouveautés, comme les décorateurs.
                </p>
                <p>
                    Ecrire du TypeScript ressemble à écrire du JavaScript. Par convention les fichiers sources
                    TypeScript ont l’extension .ts, et seront
                    compilés en JavaScript standard, en général lors du build, avec le compilateur TypeScript. Le code
                    généré reste très lisible.
                </p>
            </section>
        </section>

        <!-- II- Notions de base -->
        <section>
            <section>
                <h2>II- Notions de base</h2>
            </section>
        </section>

        <!-- II. 1. Comment une application Angular est démarrée? -->
        <section>
            <h2>II. 1. Comment une application Angular est démarrée?</h2>
        </section>

        <!-- II- 2. Un composant, c'est quoi? -->
        <section>
            <section>
                <h2>II- 2. Un composant, c'est quoi?</h2>
                <img src="assets/angular/spa.png" width="500"/>
            </section>
            <section>
                <p>Un composant Angular est un bout d’interface de votre application.</p>
            </section>
            <section>
                <p>
                    Un composant peut contenir:
                <ul>
                    <li>Un bouton</li>
                    <li>Une image</li>
                    <li>Un menu de navigation</li>
                    <li>Une page entière</li>
                    <li>...</li>
                </ul>
                </p>
            </section>
            <section>
                <p>
                <p>Un composant Angular est constitué de deux parties:</p>
                <ul>
                    <li>La classe: C’est là qu’on trouve les données à afficher et la logique applicative.</li>
                    <li>Le template: C’est la partie du composant qui sera affichée à l’utilisateur.</li>
                </ul>
                <p>Pour faire une analogie avec le pattern MVC (Model-View-Controller), on pourrait dire:</p>
                <ul>
                    <li>Classe ≈ Contrôleur</li>
                    <li>Template ≈ Vue</li>
                </ul>
                </p>
            </section>
        </section>

        <!-- II- 3. Créer un composant -->
        <section>
            <section>
                <h2>II- 3. Créer un composant</h2>
                <p>ng generate component user</p>
                <p>ng generate c user</p>
            </section>
        </section>

        <!-- II- 4. Databinding -->
        <section>
            <section>
                <h2>II- 4. Databinding</h2>
                <img src="assets/angular/hangover.gif" width="400"
                     style="background: none; border:none; box-shadow:none;"/>
            </section>
            <section>
                <p>
                <ul>
                    <li>
                        <span style="color: #6cc644;">String interpolation</span>
                        <pre><code>{{ data }}</code></pre>
                    </li>
                    <li>
                        <span style="color: #6cc644;">Property binding</span> [property]="data" ou bind-property="data",
                        par exemple:
                        <pre><code><button [disabled]="isDisabled"> ...</button></code></pre>
                    </li>
                    <li>
                        <span style="color: #6cc644;">Event Binding </span> (event)="callback()" ou
                        on-click="callback()", par exemple:
                        <pre><code><button (click)="onClick()"></button></code></pre>
                    </li>
                    <li>
                        <span style="color: #6cc644;">Two-way binding </span> (Banana in the box)
                        <pre><code>[(data)]</code></pre>
                    </li>
                </ul>
                </p>
            </section>
        </section>

        <!-- II- 5. String interpolation -->
        <section>
            <h2>II- 5. String interpolation</h2>
            <p>
                On utilise la fameuse notation avec double-accolades (les "moustaches") pour indiquer qu'une
                expression doit être évaluée, ce type de templating est appelé l’interpolation, il s'utilise
                surtout pour le print/output des propriétés:
            </p>
            <p><code>
                <pre>Hello {{ name }}</pre>
            </code></p>
        </section>

        <!-- II- 6. Property binding -->
        <section>
            <section>
                <h2>II- 6. Property binding</h2>
                <p>
                    En Angular, on peut écrire dans toutes les propriétés du DOM via des attributs spéciaux sur les
                    éléments HTML, entourés de crochets []. Ça fait bizarre au premier abord, mais en fait c’est du
                    HTML valide. Un nom d’attribut HTML peut commencer par n’importe quoi, à l’exception de quelques
                    caractères comme un guillemet ", une apostrophe ', un slash /, un égal =, un espace...
                    L’interpolation {{ name }} est juste du sucre syntaxique pour l’écriture suivante:
                </p>
                <p><code>
                    <pre><span [textContent]=[name]></span></pre>
                </code>
                </p>
                <p>Le property binding s'utilise de la façon suivante:</p>
                <p><code>
                    <pre><img [src]="user.imgUrl"></pre>
                </code>
                </p>
                <p>Ou bien,</p>
                <p>
                    <code>
                        <pre><img bind-src="user.imgUrl"></pre>
                    </code>
                </p>
            </section>
            <section>
                <h5>Attribute/class/style binding</h5>
                <p>
                    Le property binding s'utilise surtout pour changer une certaine propriété.
                    On peut également l'utiliser pour les cas suivants:
                </p>
                <p>Attribute Binding:</p>
                <p><code>
                    <pre>&lt;td [attr.colspan]="clspn"&gt;...&lt;/td&gt;</pre>
                </code>
                </p>
                <p>Class Binding:</p>
                <p><code>
                    <pre><span [class.active]="isActive">Some text</span></pre>
                </code>
                </p>
                <p>Style Binding:</p>
                <p>
                    <code>
                        <pre><span [style.background-color]="'blue'">Blue text</span></pre>
                    </code>
                </p>
                <p>Ou bien,</p>
                <p>
                    <code>
                        <pre><span [style.backgroundColor]="'blue'">Blue text</span></pre>
                    </code>
                </p>
            </section>
        </section>

        <!-- II- 7. Event binding -->
        <section>
            <section>
                <h2>II- 7. Event binding</h2>
                <p>
                    À partir d'un évènement du DOM, on peut interagir avec un composant, pour réaliser ce Data
                    Binding,
                    Angular utilise les évènements, d'où le nom d'Event Binding, avec ce mécanisme, vous pouvez être
                    averti des évènements utilisateurs tels que le click, le frappe sur le clavier.. etc, on
                    l'utilise
                    comme suit:
                </p>
                <p><code>
                    <pre><button (click)="callback()">Click</button></pre>
                </code>
                </p>
                <p>Ou bien,</p>
                <p><code>
                    <pre><button on-click="callback()">Click</button></pre>
                </code>
                </p>
                <p>/!\ Astuce: Vous pouvez faire de l'event binding spécique à certaines touches au niveau des
                    évènements Keyup & Keydown.</p>
                <p>
                    <code>
                        <pre><input (keyup.enter)="callback()"></pre>
                    </code>
                </p>
            </section>
            <section>
                <p>Voici quelques exemples supplémentaires pour vous donnez une idée de ce qui est possible:</p>

                <img src="assets/angular/eventbindings.png">
            </section>
        </section>

        <!-- II- 8. Two way binding -->
        <section>
            <h2>II- 8. Two way binding</h2>
            <p>
                Ce mécanisme permet, à partir d'une même notation, de modifier le modèle à partir du DOM et de modifier
                le DOM à partir du modèle. Voici la syntaxe utilisée dans Angular pour déclarer un tel Data Binding:
            </p>
            <p><code>
                <pre><input name="name" [(ngModel)]="user.name"></pre>
            </code>
            </p>
            <p>Ou bien,</p>
            <p><code>
                <pre><input name="name" [ngModel]="user.name" (ngModelChange)="user.name = $event"></pre>
            </code>
            </p>
        </section>

        <!-- II- 9. Une directive, c'est quoi? -->
        <section>
            <h2>II- 9. Une directive, c'est quoi?</h2>
            <p>
                Une directive est très semblable à un composant, sauf qu’elle n’a pas de template. En fait, la classe
                Component hérite de la classe Directive dans le framework.
            </p>
            <p>
                Les directives sont des briques minimalistes. On peut les concevoir comme des décorateurs pour ton
                HTML : elles attacheront du comportement aux éléments du DOM. Et tu peux avoir plusieurs directives
                appliquées à un même élément.
                Une directive doit avoir un sélecteur CSS, qui indique au framework où l’activer dans notre template.
            </p>
        </section>

        <!-- II- 10. *ngIf & *ngFor & ngSwitch -->
        <section>
            <section><h2>II- 10. *ngIf & *ngFor & ngSwitch</h2></section>
            <section>
                <h2>*ngIf / else condition</h2>
                <img src="assets/angular/ngif.png">
            </section>
            <section>
                <h2>*ngFor / index</h2>
                <p>
                <pre><code><div *ngFor="let item of items; let i = index">{{i}} - {{item.name}}</div>
                    </code></pre>
                Ou,
                <pre><code><p *ngFor="let item of items; index as i">{{i}} - {{item.name}}</p>
                    </code></pre>
                </p>
            </section>
            <section>
                <h2>ngSwitch</h2>
                <img src="assets/angular/ngswitch.png">
            </section>
        </section>

        <!-- II- 11. ngClass & ngStyle -->
        <section>
            <section><h2>II- 11. ngClass & ngStyle</h2></section>
            <section>
                <h2>ngClass</h2>
                <img src="assets/angular/ngclass.png">
            </section>
            <section>
                <h2>ngStyle</h2>
                <p>
                    <code>
                        <pre><span [ngStyle]="{'background-color':'green'}"></span></pre>
                    </code>
                </p>
                <p>
                    <code><pre><span [ngStyle]="{'background-color':person.country === 'UK' ? 'green' : 'red' }"></span>
                    </pre>
                    </code>
                </p>
            </section>
        </section>

        <!-- II- 12. debugging -->
        <section>
            <section>
                <h2>II- 12. Debugging</h2>
                <p><a href="https://augury.rangle.io/">https://augury.rangle.io/</a></p>
            </section>
        </section>

        <!-- III- Components -->
        <section>
            <section>
                <h2>III- Components</h2>
            </section>
        </section>

        <!-- III- 1. template/templateUrl -->
        <section>
            <section>
                <h2>III- 1. template/templateUrl</h2>
            </section>
        </section>

        <!-- III- 2. selector -->
        <section>
            <section>
                <h2>III- 2. selector</h2>
            </section>
        </section>

        <!-- III- 3. styles/styleUrls -->
        <section>
            <section>
                <h2>III- 3. styles/styleUrls</h2>
            </section>
        </section>

        <!-- III- 4. @Input -->
        <section>
            <section>
                <h2>III- 4. @Input</h2>
            </section>
        </section>

        <!-- III- 5. @Output -->
        <section>
            <section>
                <h2>III- 5. @Output</h2>
                <p>Quand @Input se charge de recevoir une valeur, @Output se charge, lui, d'envoyer une donnée.</p>
                <img src="assets/angular/7.png" width="400" style="background: none; border:none; box-shadow:none;"/>
            </section>
        </section>

        <!-- III- 6. @Encapsulation -->
        <section>
            <h2>III- 6. @Encapsulation</h2>
            <ul>
                <li>
                    <span style="color: #6cc644;">encapsulation: ViewEncapsulation.Emulated</span> Pas de shadow DOM,
                    mais une émulation du Shadow DOM. C'est le comportement par défaut.
                </li>
                <li>
                    <span style="color: #6cc644;">encapsulation: ViewEncapsulation.Native </span> Utilisation du
                    véritable shadow DOM. Superbe sur Chrome, mais cela s'arrête là pour le moment. Ni Safari, ni
                    Firefox ne supporte ce mécanisme.
                </li>
                <li>
                    <span style="color: #6cc644;">encapsulation: ViewEncapsulation.None </span> Ni shadow DOM, ni aucun
                    mécanisme d'encapsulation de style CSS.
                </li>
            </ul>
        </section>

        <!-- III- 7. Template reference variables -->
        <section>
            <h2>III- 7. Template reference variables</h2>
            <p>Les variables référence de template (ou template reference variables) permettent d’accéder à un élément
                DOM ou un composant Angular via une variable déclarée directement sur la balise de cet élément ou de ce
                composant avec la syntaxe #var ou ref-var.</p>
        </section>

        <!-- III- 8. @ViewChild -->
        <section>
            <h2>III- 8. @ViewChild </h2>
            <p>Vous pouvez utiliser ViewChild pour obtenir le premier élément ou la directive correspondant au sélecteur
                de la vue DOM.</p>
        </section>

        <!-- III- 9. @ContentChild -->
        <section>
            <h2>III- 9. @ContentChild </h2>
            <p>Vous pouvez utiliser ContentChild pour obtenir le premier élément ou la directive correspondant au
                sélecteur du DOM de contenu.</p>
        </section>

        <!-- III- 10. Cycle de vie d'un composant (Hooks) -->
        <section>
            <section>
                <h2>III- 10. Cycle de vie d'un composant (Hooks)</h2>
                <p>Pour ceux qui ne connaissent pas le terme de cycle de vie, il s'agit simplement de la définition de
                    toutes les étapes de la naissance du Component à sa mort.</p>
                <img src="assets/angular/8.png" width="300" style="background: none; border:none; box-shadow:none;"/>
            </section>
            <section>
                <h3>ngOnChanges</h3>
                <p>
                    Se lance lorsqu'Angular modifie une des propriétés du Component / directive suite à un Property
                    Binding <span style="color: #6cc644;">@Input</span>. La méthode reçoit un object SimpleChanges
                    contenant les valeurs courantes et précédentes.

                    Il est lancé avant <span style="color: #6cc644;">ngOnInit</span> et à chaque fois qu'une ou
                    plusieurs propriétés précédées de <span style="color: #6cc644;">@Input</span> change.
                </p>
            </section>
            <section>
                <h3>ngOnInit</h3>
                <p>Initialise le component / directive après qu'Angular ait valorisé les Property Binding <span
                        style="color: #6cc644;">@Input</span>. Il n'est lancé qu'une seule fois après le premier .
                </p>
            </section>
            <section>
                <h3>ngDoCheck</h3>
                <p>Détecte et agit sur les changements qu'Angular ne peut ou ne pourra pas détecter lui même. Il permet,
                    en outre, de vérifier les changements dans les directives additionnelement aux algorithmes
                    classiques. Il est appelé immédiatement après <span style="color: #6cc644;">ngOnChanges</span> et
                    <span style="color: #6cc644;">ngOnInit</span>.</p>
            </section>
            <section>
                <h3>ngAfterContentInit</h3>
                <p>Il se lance également après l'initialisation d'un Content (ng-content). A partir de ce moment, les
                    propriétés initialisées par <span style="color: #6cc644;">@ContentChild</span> et <span
                            style="color: #6cc644;">@ContentChildren</span> sont valorisées.

                    Il n' est appelé qu'une fois après le premier <span style="color: #6cc644;">ngDoCheck</span>. </p>
            </section>
            <section>
                <h3>ngAfterContentChecked</h3>
                <p>Se lance après le check du Content.</p>
            </section>
            <section>
                <h3>ngAfterViewInit</h3>
                <p>Se lance après qu'Angular initialise la vue (template) du Component et les vues enfants. A partir de
                    ce moment, les propriétés initialisées <span style="color: #6cc644;">@ViewChild</span> et <span
                            style="color: #6cc644;">@ViewChildren</span> sont valorisées

                    Il n'est appelé qu'une seule fois après <span style="color: #6cc644;">ngAfterContentChecked</span>.
                </p>
            </section>
            <section>
                <h3>ngAfterViewChecked</h3>
                <p>Se lance après le check de la vue (template)</p>
            </section>
            <section>
                <h3>ngOnDestroy</h3>
                <p>Se lance juste avant qu'Angular ne détruise le Component / directive. C'est l'endroit idéal pour
                    desinscrire les Observables et détacher les évènements afin d'éviter les fuites mémoires.

                    Il est appelé qu'une seule fois avant la destruction du Component / directive.</p>
            </section>
        </section>

        <!-- IV- Directives -->
        <section>
            <section>
                <h3>IV- Directives</h3>
            </section>
            <section>
                <p>Il existe deux sortes de directives:</p>
                <ul>
                    <li>Les directives structurelles: Elles ont pour but de modifier le DOM en ajoutant, enlevant ou
                        replaçant un élément du DOM.
                    </li>
                    <li>
                        Les attribute directives: Elles ont pour but de modifier l'apparence ou le comportement d'un
                        élément.
                    </li>
                </ul>
            </section>
        </section>


        <!-- IV- 1. Les directives structurelles -->
        <section>
            <h3>IV- 1. Les directives structurelles</h3>
            <ul>
                <li>*ngIf</li>
                <li>*ngFor</li>
            </ul>
        </section>

        <!-- IV- 2. Les directives directives -->
        <section>
            <h3>IV- 2. Les directives directives</h3>
            <ul>
                <li>NgClass</li>
                <li>NgStyle</li>
            </ul>
        </section>

        <!-- IV- 3. ElementRef -->
        <section>
            <h3>IV- 3. ElementRef</h3>
            <p>
                <code>
                    <pre>constructor(private elementRef: ElementRef) {}</pre>
                </code>
            </p>
            <p>
                <code>
                    <pre>ngOnInit() { this.elementRef.nativeElement.style.backgroundColor = 'green'; }</pre>
                </code>
            </p>
        </section>

        <!-- IV- 4. Renderer -->
        <section>
            <h3>IV- 4. Renderer</h3>
            <p>
                <code>
                    <pre>constructor(private elRef: ElementRef, private renderer: Renderer2) {}</pre>
                </code>
            </p>
            <p>
                <code>
                    <pre>ngOnInit() { this.renderer.setStyle(this.elRef.nativeElement, 'backgroundColor', 'blue'); }</pre>
                </code>
            </p>
        </section>

        <!-- IV- 5. @HostBinding -->
        <section>
            <h3>IV- 5. @HostBinding</h3>
            <p><code>
                <pre>@HostBinding('style.backgroundColor') backgroundColor;</pre>
            </code>
            </p>
            <p>
                <code>
                    <pre>ngOnInit() { this.backgroundColor = 'blue'; }</pre>
                </code>
            </p>
        </section>

        <!-- IV- 6. @HostListener -->
        <section>
            <h3>IV- 6. @HostListener</h3>
            <p><code>
                <pre>@HostListener('mouseenter') mouseenter(eventData: Event) { this.backgroundColor = this.highlightColor; }</pre>
            </code></p>
        </section>

        <!-- IV- 7. @Input -->
        <section>
            <h3>IV- 7. @Input</h3>
            <div>
                <pre><code>@Input() highlightColor = 'transparent';</code></pre>
            </div>
            <div>Côté HTML: <pre><code>
            <p appBetterHighlight [highlightColor]="'blue'">Highlight
                Directive</p></code></pre></div>
            <div>ou bien,
                <pre><code><p appBetterHighlight highlightColor="blue">Highlight Directive</p>
                        </code></pre></div>
        </section>

        <!-- V- Services & Injection des dépendances -->
        <section>
            <section>
                <h2>V- Services & Injection des dépendances</h2>
                <p>
                    "Components shouldn't fetch or save data directly and they certainly shouldn't knowingly present
                    fake data. They should focus on presenting data and delegate data access to a service."
                </p>
            </section>
        </section>

        <!-- V- 1. @Injectable -->
        <section>
            <h3>V- 1. @Injectable </h3>
            <p>@Injectable() lets Angular know that a class can be used with the dependency injector.</p>
        </section>

        <!-- V- 2. Providers -->
        <section>
            <h3>V- 2. Providers</h3>
        </section>

        <!-- V- 3. @Inject -->
        <section>
            <h3>V- 3. @Inject</h3>
            <p>@Inject() is a manual mechanism for letting Angular know that a parameter must be injected.</p>
        </section>

        <!-- V- 4. providedIn -->
        <section>
            <h3>V- 4. providedIn</h3>
        </section>

        <section>
            <section>
                <h2>ngStore</h2>
                <p>
                    RxJS powered state management for Angular applications, inspired by Redux.
                </p>
            </section>
            <section>
                <h2>Implementations</h2>
                <ul>
                    <li>@ngrx/store</li>
                    <li>ng2-redux</li>
                    <li>@angular-redux/store...</li>
                </ul>
            </section>
            <section>
                <h3>npm i -S @ngrx/store</h3>
            </section>
            <section>
                <h3>npm i -S @ngrx/store-devtools</h3>
                <p>@ngrx/store-devtools instruments your store letting you use a powerful time-travelling
                    debugger.</p>
            </section>
            <section>
                <h3>npm i -S @ngrx/entity</h3>
                <p>@ngrx/entity provides an API to manipulate and query entity collections.</p>
            </section>
            <section>
                <h3>npm i -S @ngrx/router-store</h3>
                <p>Keeps the state of @angular/router in your store.</p>
            </section>
            <section>
                <h3>npm i -S @ngrx/effects</h3>
                <p>Isolates side effects from your UI by expressing side effects as sources of actions.</p>
            </section>
            <section>
                <h3>Actions</h3>
                <p>Actions describe state changes.</p>
            </section>
            <section>
                <h3>Reducers</h3>
                <p>Pure functions called reducers take the previous state and the next action to compute the new
                    state.</p>
                <p>Reducers specify how the application's state changes in response to actions sent to the
                    store.</p>
                <p>Remember that actions only describe what happened, but don't describe how the application's state
                    changes.</p>
            </section>
            <section>
                <h3>NgRx Schematics</h3>
                <ul>
                    <li>ng config cli.defaultCollection @ngrx/schematics</li>
                    <li>npm i -D @ngrx/schematics</li>
                    <li>ng generate entity --name User --module somewhere/somewhere.module.ts</li>
                    <li>https://github.com/ngrx/platform/tree/master/docs/</li>
                </ul>
            </section>
            <section>
                <h3>Dependencies</h3>
                <p>npm i @ngrx/{store,effects,entity,store-devtools} -S</p>
            </section>
        </section>
    </div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>

    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme || 'night', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        parallaxBackgroundImage: 'assets/bg.jpg',
        parallaxBackgroundSize: '1500px 1000px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
            {
                src: 'lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {
                src: 'plugin/zoom-js/zoom.js', async: true, condition: function () {
                return !!document.body.classList;
            }
            },
            {
                src: 'plugin/notes/notes.js', async: true, condition: function () {
                return !!document.body.classList;
            }
            }
        ]
    });

</script>

<script src="js/raphael-min.js"></script>
<script src="js/underscore-min.js"></script>
<script src="js/sequence-diagram-min.js"></script>

<script>
    var webHooksDiagram = Diagram.parse(
        "participant User\n" +
        "Provider->GitHub: Register OAuth Application (optional)\n" +
        "GitHub-->Provider: Client ID & Secret\n" +
        "User->Provider: Request WebHook URI\n" +
        "Provider-->User:\n" +
        "User->GitHub: Add WebHook\n" +
        "GitHub->Provider: Call WebHook\n" +
        "Provider-->User: Provide Service\n"
    );
    webHooksDiagram.drawSVG("webHooksDiagram", {theme: 'hand'});

    var serviceHooksDiagram = Diagram.parse(
        "participant User\n" +
        "Provider->GitHub: Develop Service Hook\n" +
        "User->Provider: Request Access Key (optional)\n" +
        "Provider-->User:\n" +
        "User->GitHub: Configure Service Hook\n" +
        "GitHub->Provider: Call Service Hook\n" +
        "Provider-->User: Provide Service\n"
    );
    serviceHooksDiagram.drawSVG("serviceHooksDiagram", {theme: 'hand'});

    var accountIntegrationDiagram = Diagram.parse(
        "participant User\n" +
        "User->Provider: Configure Service\n" +
        "Provider->GitHub: Request Access\n" +
        "GitHub->User:\n" +
        "User-->GitHub:\n" +
        "GitHub-->Provider: Grant Access\n" +
        "Provider->GitHub: Configure Service- or WebHook\n" +
        "GitHub->Provider: Call Hook\n" +
        "Provider-->User: Provide Service\n"
    );
    accountIntegrationDiagram.drawSVG("accountIntegrationDiagram", {theme: 'hand'});

    var serviceChainDiagram = Diagram.parse(
        "participant User\n" +
        "participant PAAS Provider\n" +
        "participant QA Provider\n" +
        "participant CI Provider\n" +
        "GitHub->CI Provider: Trigger Build\n" +
        "CI Provider->QA Provider: Static Analysis\n" +
        "QA Provider-->User: Send Results\n" +
        "CI Provider->PAAS Provider: Deploy\n" +
        "PAAS Provider-->User: Running Instance\n"
    );
    serviceChainDiagram.drawSVG("serviceChainDiagram", {theme: 'hand'});

</script>

<div class="hidden-mobile">
    <div style="display: block; position: absolute; bottom: 14px; left: 50%; margin-left: -230px; z-index: 20;">
        <a href="https://twitter.com/bkimminich" class="twitter-follow-button" data-show-count="false">Follow
            @bkimminich</a>
        <script>!function (d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location) ? 'http' : 'https';
            if (!d.getElementById(id)) {
                js = d.createElement(s);
                js.id = id;
                js.src = p + '://platform.twitter.com/widgets.js';
                fjs.parentNode.insertBefore(js, fjs);
            }
        }(document, 'script', 'twitter-wjs');</script>
        <a href="https://twitter.com/share" class="twitter-share-button"
           data-url="http://github-service-universe.kimminich.de"
           data-text="Exploring the @GitHub Service Universe (presented at @JavaLandConf and @Clean_Code_Days 2015)"
           data-via="bkimminich">Tweet</a>
        <script>!function (d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location) ? 'http' : 'https';
            if (!d.getElementById(id)) {
                js = d.createElement(s);
                js.id = id;
                js.src = p + '://platform.twitter.com/widgets.js';
                fjs.parentNode.insertBefore(js, fjs);
            }
        }(document, 'script', 'twitter-wjs');</script>
        <iframe src="https://ghbtns.com/github-btn.html?user=bkimminich&type=follow&count=true" frameborder="0"
                scrolling="0" width="170px" height="20px"></iframe>
        <iframe src="https://ghbtns.com/github-btn.html?user=bkimminich&repo=github-service-universe&type=star&count=true"
                frameborder="0" scrolling="0" width="170px" height="20px"></iframe>
    </div>
</div>


</body>
</html>
